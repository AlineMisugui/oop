
var: problemas de escopo, não tem block scope

let: substituiu var no ES6

const: constante, não dá para retribuir um valor

Formas de criar objetos: object literal, factory e constructor


** OBJECT LITERALS **

    É uma maneira rápida e literal de criar um objeto, passando entre o par de chaves { } a propriedade e o seu respectivo valor: let obj = { name: "Rocketseat",  bootcamp: "Go Stack", propriedade: "valor"}
    Podemos usar objects literals para substituir a estrutura switch case e if else

    Veja um exemplo de código com switch:

    <code>
        let day;

        switch (new.Date().getDay()); {
            case 0: 
                day = 'Sunday';
                break;
            case 1: 
                day = 'Monday';
                break;
            case 2: 
                day = 'Tuesday';
                break;
            case 3:
                day = 'Wednesday';
                break;
            case 4:
                day = 'Thursday';
                break;
            case 5:
                day = 'Friday';
                break;
            case 6: 
                day = 'Sturday';
                break;
            default:
                throw new Error('Hey! We have only 7 days in the week!');
        }

        console.log(`What day of the week is today? ${day}`);
    </code>

    Agora veja o mesmo exemplo com o uso de object literal

    <code>
        const daysOfTheWeek = {
            0: "Sunday";
            1: "Monday";
            2: "Tuesday";
            3: "Wednesday";
            4: "Thursday";
            5: "Friday";
            6: "Saturday";
        };

        console.log(`What day of the week is today? ${dayOfTheWeek[new Date().getDay()]}`);
    </code>
    
    O uso de object literal permite maior legibilidade e não corremos o risco de esquecer algum break 
    Object literal syntax, não é bom quando você precisa duplicar esse objeto e ele tem pelo menos um método 
    Solução usar factory ou constructor

** FACTORY **

    o padrão factory estabelece uma forma de desenvolver objetos que são responsáveis pela criação de outros objetos.
    Este padrão encapsula a criação de objetos a partir de um de seus métodos, funcionando como uma fábrica de objetos propriamente dita
    O retorno da função é puramente um objeto, sem exigir que vc use classe, constructors e o operador new.
    é mais dinâmico, facilita manutenção e encapsula 

    <code>
        const circle = {
            radius: 1,
            location: {
                x: 1,
                y: 1
            }
        };

        const circle = {
            radius: 2,
            location: {
                x: 2,
                y: 2
            }
        };
    </code>

    Otimizado:
    <code>
        function createCircle(radius) {
            return {
                radius,
                draw() {
                    console.log('draw');
                }
            }
        };

        const circle = createCircle(1);
        circle.draw();
    </code>

    outro exemplo: 
    <code>
        function cadastrarLivro(titulo, autor, editora) { // Perceba o encapsulamento e a facilidade de manutenção
            return {
                titulo,
                autor,
                editora,
                eUsado() {
                    console.log('Verificando se o livro é novo ou usado...');
                }
            }
        }

        const livro = cadastrarLivro('Dom Casmurro e os discos voadores', 'ASSIS, Machado de; MANFREDI, Lúcio', 'Lua de Papel');
        console.log(livro);
        livro.eUsado();
    </code>

** CONSTRUCTOR **
    function Circle(radius) {
        this.radius = radius;
        this.draw = function() {
            console.log('draw');
        }
    }

    const another = new Circle(1);